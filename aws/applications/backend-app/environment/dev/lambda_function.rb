require 'aws-sdk-lambda'
require 'aws-sdk-s3'
require 'aws-sdk-sqs'
require 'json'
require 'mail'
require 'base64'

  # Env variables set at lambda function

  AWS_REGION = ENV["MA_REGION"]
  AWS_INCOMING_BUCKET = ENV["MA_BUCKET"]
  DEBUG_MODE = ENV["DEBUG_MODE"]

  def lambda_handler(event:, context:)
      message_id = event['Records'][0]['ses']['mail']['messageId']
      receipt = event['Records'][0]['ses']['receipt']

      puts("MaIncoming: [Info] (#{message_id}): AWS_INCOMING_BUCKET #{AWS_INCOMING_BUCKET}")
      puts("MaIncoming: [Info] (#{message_id}): AWS_REGION #{AWS_REGION}")

      puts("MaIncoming: [Info] (#{message_id}): Received message.")
      puts("MaIncoming: [Info] (#{message_id}): Received receipt #{receipt.inspect}") if DEBUG_MODE

      is_bounce = receipt && receipt.dmarcVerdict.status === 'FAIL' && receipt.dmarcPolicy.status === 'REJECT' rescue false
      if is_bounce
        puts("MaIncoming: [Error] (#{message_id}): Bounced")
        return { statusCode: 200, body: 'Mail Bounced!' }
      end

      begin
        client = Aws::S3::Client.new(region: AWS_REGION)

        object_path = "raw/#{message_id}"
        object_http_path = ("http://s3.console.aws.amazon.com/s3/object/#{AWS_INCOMING_BUCKET}/#{object_path}?region=#{AWS_REGION}")
        object_s3 = client.get_object(bucket: AWS_INCOMING_BUCKET,key: object_path)

        file = object_s3.body.read
        mail_obj = Mail.read_from_string file

        puts("MaIncoming: [Info] (#{message_id}): mail_obj #{mail_obj.inspect}") if DEBUG_MODE
        puts("MaIncoming: [Info] (#{message_id}): Read Success.")
      rescue Exception => e
        puts("MaIncoming: [Error] (#{message_id}): Read Failed. #{e.message}")
        puts e.backtrace.inspect
      end
      
      if is_auto_generated_mail(mail_obj)
        puts("MaIncoming: [Info] (#{message_id}): Ignored as AutoGenerated Email.")
        return { statusCode: 200, body: 'Mail Ignored!' }
      end

      recpt_klass = mail_obj.received.class
      if recpt_klass == Array
        rcpt = mail_obj.received.map{|a| a.value.match(/([=a-zA-Z0-9._-]+@[a-zA-Z0-9._-]+\.[a-zA-Z0-9_-]+)/).to_a}.compact.flatten.uniq[0] rescue nil
      else
        rcpt = [mail_obj.received].map{|a| a.value.match(/([=a-zA-Z0-9._-]+@[a-zA-Z0-9._-]+\.[a-zA-Z0-9_-]+)/).to_a}.compact.flatten.uniq[0] rescue nil
      end

      puts("MaIncoming: [Info] (#{message_id}): rcpt #{rcpt}")

      rcpts = rcpt.nil? ? [] : [rcpt]

      if rcpts.empty?
        to_lists = []
        to_lists = mail_obj.to 
        to_lists = to_lists + mail_obj.cc if mail_obj.cc
        rcpts = to_lists.select{|e| e if ENV[e.split("@").last.gsub('.', '_').gsub('-', '_')]}
      end

      return { statusCode: 500, body: 'Recipient Not Found' } if rcpts.empty?

      mailer_ip = begin
                    mail_obj.header['Received'][0].value[/\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}/]
                  rescue
                    mail_obj.header['Received'].element.info[/\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}/] rescue nil
                  end

      # This should also be present
      # 'us_mangoapps_com' => "https://sqs.eu-west-1.amazonaws.com/760042596542/mail-ee-incoming",
      # 'zenithmail_teamhealth_com' => "https://sqs.eu-west-1.amazonaws.com/760042596542/mail-ee-incoming",
      
      # USDC
      # rcpt_host = "us.mangoapps.com"

      # ZENITH
      # rcpt_host = "zenithmail.teamhealth.com"
      result_arr = []
      rcpts.each do |rcpt|
        rcpt_host = rcpt.split("@").last
        rcpt_name = rcpt.split("@").first
        rcpt_id = Base64.urlsafe_encode64(rcpt_name, padding: false)
        rcpt_msg_id = "#{message_id}_#{rcpt_id}"
        ma_sqs_url = ENV[rcpt_host.gsub('.', '_').gsub('-', '_')]
        puts("MaIncoming: [Info] (#{rcpt_msg_id}): ma_sqs_url #{ma_sqs_url}")
        result_arr << 'INVALID_HOST' if !ma_sqs_url || ma_sqs_url.empty?
        next if !ma_sqs_url || ma_sqs_url.empty?
        has_attachments = false
        att_meta_data = []
        out_path_prefix = "processed/#{rcpt_host}/#{rcpt_msg_id}"

        mail_obj.attachments.map do |attachment|
          has_attachments = true
          att_meta_data << {filename: attachment.filename, inline: attachment.inline?, url: attachment.url}
          client.put_object({
              body: attachment.decoded, 
              bucket: AWS_INCOMING_BUCKET, 
              key: "#{out_path_prefix}/attachments/#{attachment.filename}", 
          })
        end

        email_meta = {
          id: "#{rcpt_msg_id}",
          message_id: mail_obj.message_id.nil? ? message_id : mail_obj.message_id,
          references: mail_obj.references,
          subject: mail_obj.subject,
          from: mail_obj.from,
          to: mail_obj.to,
          cc: mail_obj.cc,
          mailer_ip: mailer_ip,
          has_attachments: has_attachments,
          html_part: !mail_obj.html_part.nil?,
          text_part: !mail_obj.text_part.nil?,
          rcpt: rcpt,
          host: rcpt_host
        }

        puts("MaIncoming: [Info] (#{rcpt_msg_id}): email_meta #{email_meta.inspect}") if DEBUG_MODE

        client.put_object({
          body: email_meta.to_json, 
          bucket: AWS_INCOMING_BUCKET, 
          key: "#{out_path_prefix}/email_meta.json",
        })

        client.put_object({
          body: get_mail_body(mail_obj), 
          bucket: AWS_INCOMING_BUCKET, 
          key: "#{out_path_prefix}/email_body.txt",
        })

        client.put_object({
          body: att_meta_data.to_json, 
          bucket: AWS_INCOMING_BUCKET, 
          key: "#{out_path_prefix}/attachment_meta.json",
        })

        puts("MaIncoming: [Info] (#{rcpt_msg_id}): Processed and Saved message #{out_path_prefix}")

        sqs_meta = {
          id: rcpt_msg_id,
          message_id: mail_obj.message_id.nil? ? message_id : mail_obj.message_id,
          subject: mail_obj.subject,
          from: mail_obj.from,
          to: mail_obj.to,
          rcpt: rcpt,
          host: rcpt_host,
          has_attachments: has_attachments
        }

        client_sqs = Aws::SQS::Client.new(region: AWS_REGION)
        resp = client_sqs.send_message({
          queue_url: ma_sqs_url, # required
          message_body: JSON.generate(sqs_meta), # required
        })

        puts("MaIncoming: [Info] (#{rcpt_msg_id}): Meta Saved to SQS #{out_path_prefix}")
      end

      if rcpts.size == result_arr.size
        puts("MaIncoming: [Error] (#{message_id}): Ignored Due to invalid host.")
        return { statusCode: 200, body: 'Mail Ignored! - Due to invalid host' }
      else
        return { statusCode: 200, body: 'Success' } #Need to ask
      end
  end

  def get_mail_body(mail)
    if !mail.html_part.nil?
      body_text= mail.html_part.decoded.gsub("\"","'").to_s rescue ''
    elsif !mail.text_part.nil?
      body_text= mail.text_part.to_s.gsub("\n", "<br>") rescue ''
    else
      body_text = mail.body.to_s.gsub("\n", "<br>") rescue ''
    end
    return body_text
  end

  # Method to check if the incoming mail is an auto-reply mail (for cases like Out-Of-Office)
  # Refernce : http://tools.ietf.org/html/rfc3834#section-5
  def is_auto_generated_mail(mail)
      ignore_from_list = ['MAILER-DAEMON@']
      ignore_from_list.each do |igf|
          return true if mail.from.first.include?(igf)
      end

      auto_submitted_field = mail.header.fields.select do |header_field|
        header_field.field && header_field.field.class == Mail::OptionalField &&
        ((header_field.field.name.respond_to?(:wrapped_string) && header_field.field.name.wrapped_string.to_s.downcase == 'auto-submitted') || (header_field.field.name.to_s.downcase == 'auto-submitted'))
      end
      received_field = mail.header.fields.select do |header_field|
        header_field.field && header_field.field.class == Mail::ReceivedField &&
        header_field.field.name && header_field.field.name.to_s.downcase == 'received'
      end
      x_auto_reply = mail.header.fields.select do |header_field|
        header_field.field && header_field.field.class == Mail::OptionalField &&
        header_field.field.name && x_auto_reply_header_values.include?(header_field.field.name.to_s.downcase)
      end
      if (!auto_submitted_field.empty? && ['auto-generated', 'auto-replied', 'auto-notified','automatic reply','automatic-reply'].include?(auto_submitted_field.first.value.to_s.downcase) &&
        received_field.map {|field| !field.value.to_s.downcase.scan(/zendesk.com/).empty?}.include?(true)) || !x_auto_reply.empty? ||
        !mail.subject.to_s.downcase.scan(auto_reply_subjects).empty?
        return true
      end
      return false
    end
    
    def x_auto_reply_header_values
      @x_auto_reply_header_values ||= [ 'x-autoreply',
                                        'X-autorespond',
                                        'x-mc-system',
                                        'x-fc-machinegenerated',
                                        'x-autogenerated']
    end
    
    def auto_reply_subjects
      /auto:|auto responder|automatic reply|auto-response|auto response|auto-generated|auto-replied|auto-notified|out of office|undelivered mail returned to sender|abwesen|out of the office/
    end
